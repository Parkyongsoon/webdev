let redis,twilio,jwt,promisify,dotenv,db;_81e‍.x([["index",()=>index],["nameAuthNumber",()=>nameAuthNumber],["confirmAuthNumber",()=>confirmAuthNumber]]);_81e‍.w("redis",[["default",["redis"],function(v){redis=v}]]);_81e‍.w("twilio",[["default",["twilio"],function(v){twilio=v}]]);_81e‍.w("jsonwebtoken",[["default",["jwt"],function(v){jwt=v}]]);_81e‍.w("util",[["promisify",["promisify"],function(v){promisify=v}]]);_81e‍.w("dotenv",[["default",["dotenv"],function(v){dotenv=v}]]);_81e‍.w("../../../models",[["db",["db"],function(v){db=v}]]);





dotenv.config();



const { JWT_SECRET, TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN } = process.env;

const redisClient = redis.createClient();

const setexAsync = promisify(redisClient.setex).bind(redisClient);
const getAsync = promisify(redisClient.get).bind(redisClient);
const delAsync = promisify(redisClient.del).bind(redisClient);


       const index = async ctx => {
  try {
  ctx.status = 200;
  
  await ctx.render('user/myPage/nameAuth/index', {
    errorMsg: ''
  });
  
  } catch (e) {
    ctx.throw(500, e);
  };
};

       const nameAuthNumber = async ctx => {
  try {
    const { phone } = ctx.request.body;
    const confirm = await db.tbl_eluly_users.findOne({
      where: {
        phone: phone
      }});

    if(!confirm) {
      
      ctx.status = 200;

      return ctx.body = {
        trueOrFalse: false,
        errorMsg: '일치하는 번호가 없다'
      }
    } else {
      const token = ctx.cookies.get('token');
      const payload = jwt.verify(token, JWT_SECRET);
      const accountSid = TWILIO_ACCOUNT_SID;
      const authToken = TWILIO_AUTH_TOKEN;
      // const client = twilio(accountSid, authToken);
      const client = require('twilio')(accountSid, authToken)

      let result = Math.floor(Math.random() * 1000000);
      const time = 300;
      let min = '';
      let sec = '';

      let timer = setInterval(() => {
        min = parseInt(time/60);
        sec = time%60;

        time--;
        
        if(time < 0) {
          clearInterval(timer)
        }
      }, 300);

      await setexAsync('nameAuth' + payload.userId, 300, result.toString());
      
      client.messages
        .create({
           body: `인증 번호 [${result}] 입력`,
           from: '+19375193604',
           to: `+82${confirm.phone}`
         })
        .then(message => _81e‍.g.console.log(message.sid))
        .catch(e => _81e‍.g.console.log(e));
      
      ctx.status = 200;

      return ctx.body = {
        trueOrFalse: true,
        timer: timer
      };

    }
  } catch (e) {
    _81e‍.g.console.log(500, e);
  };
};

       const confirmAuthNumber = async ctx => {
  try {
    const { authNumber } = ctx.request.body;
    const token = ctx.cookies.get('token');
    const payload = jwt.verify(token, JWT_SECRET);
    const reply = await getAsync('nameAuth' + payload.userId);

    _81e‍.g.console.log(authNumber);
    _81e‍.g.console.log(reply)
    _81e‍.g.console.log(authNumber === reply)

    if(authNumber !== reply) {

      ctx.status = 200;
      
      return ctx.body = {
        trueOrFalse: false,
        errorMsg: '번호 틀림 다시 입력'
      };
    } else {

      await delAsync('nameAuth' + payload.userId);

      ctx.status = 200;

      return ctx.body = {
        trueOrFalse: true
      }
    }
  } catch (e) {
    ctx.throw(500, e);
  };
};